# Generated by getoptions (BEGIN)
# URL: https://github.com/ko1nksm/getoptions (v3.3.2)
GMASH_MONO_ARGR=''
gmash_parser_mono() {
	OPTIND=$(($#+1))
	while OPTARG= && [ "${GMASH_MONO_ARGR}" != x ] && [ $# -gt 0 ]; do
		set -- "${1%%\=*}" "${1#*\=}" "$@"
		while [ ${#1} -gt 2 ]; do
			case $1 in (*[!a-zA-Z0-9_-]*) break; esac
			case '--help' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --help"
			esac
			case '--version' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --version"
			esac
			break
		done
		case ${OPTARG# } in
			*\ *)
				eval "set -- $OPTARG $1 $OPTARG"
				OPTIND=$((($#+1)/2)) OPTARG=$1; shift
				while [ $# -gt "$OPTIND" ]; do OPTARG="$OPTARG, $1"; shift; done
				set "Ambiguous option: $1 (could be $OPTARG)" ambiguous "$@"
				parser_error "$@" >&2 || exit $?
				echo "$1" >&2
				exit 1 ;;
			?*)
				[ "$2" = "$3" ] || OPTARG="$OPTARG=$2"
				shift 3; eval 'set -- "${OPTARG# }"' ${1+'"$@"'}; OPTARG= ;;
			*) shift 2
		esac
		case $1 in
			--?*=*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%%\=*}" "${OPTARG#*\=}"' ${1+'"$@"'}
				;;
			--no-*|--without-*) unset OPTARG ;;
			-[hv]?*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%"${OPTARG#??}"}" -"${OPTARG#??}"' ${1+'"$@"'}
				case $2 in --*) set -- "$1" unknown "$2" && GMASH_MONO_ARGR=x; esac;OPTARG= ;;
			+*) unset OPTARG ;;
		esac
		case $1 in
			'-h'|'--help')
				gmash_mono_help
				exit 0 ;;
			'-v'|'--version')
				echo "${GMASH_MONO_VERSION}"
				exit 0 ;;
			--)
				while [ $# -gt 0 ]; do
					GMASH_MONO_ARGR="${GMASH_MONO_ARGR} \"\${$(($OPTIND-$#))}\""
					shift
				done
				break ;;
			[-+]?*) set "unknown" "$1"; break ;;
			*)
				case $1 in 'sub'|'remove'|'pull'|'push'|'config'|'clone') ;;
					*) set "notcmd" "$1"; break
				esac
				while [ $# -gt 0 ]; do
					GMASH_MONO_ARGR="${GMASH_MONO_ARGR} \"\${$(($OPTIND-$#))}\""
					shift
				done
				break ;;
		esac
		shift
	done
	[ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }
	case $1 in
		unknown) set "Unrecognized option: $2" "$@" ;;
		noarg) set "Does not allow an argument: $2" "$@" ;;
		required) set "Requires an argument: $2" "$@" ;;
		pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;
		notcmd) set "Not a command: $2" "$@" ;;
		*) set "Validation error ($1): $2" "$@"
	esac
	parser_error "$@" >&2 || exit $?
	echo "$1" >&2
	exit 1
}
gmash_mono_help() {
cat<<'GETOPTIONSHERE'
Usage: gmash mono <sub-command> [[args]...]
 
Git+GitHub monorepo workflow strategy.
Call [main-cmd] [sub-cmd] --help for details of each sub-command.
 
Sub-Commands:
  sub                                   Add or re-configure a sub project to the mono repo as a subtree.
  remove                                Remove a subtree from the monorepo.
  pull                                  Pull changes from a sub project's remote into the mono repo.
  push                                  Push changes in the mono repo to a sub project's remote.
  config                                Configure a mono repo's remotes based on stored subproject metadata.
  clone                                 Clone repo from remote or local and add subtrees based on stored metadata.
 
Display:
  -h,     --help                        Display gmash, command or subcommand help. Use -h or --help.
  -v,     --version                     [v0-0-0] Display command group version.
GETOPTIONSHERE
}
# Generated by getoptions (END)
# Generated by getoptions (BEGIN)
# URL: https://github.com/ko1nksm/getoptions (v3.3.2)
export GMASH_MONO_SUB_PREFIX=''
export GMASH_MONO_SUB_REMOTE=''
export GMASH_MONO_SUB_URL=''
export GMASH_MONO_SUB_BR=''
export GMASH_MONO_SUB_SQUASH=''
export GMASH_MONO_SUB_NEW=''
GMASH_MONO_SUB_ARGR=''
gmash_parser_mono_sub() {
	OPTIND=$(($#+1))
	while OPTARG= && [ "${GMASH_MONO_SUB_ARGR}" != x ] && [ $# -gt 0 ]; do
		set -- "${1%%\=*}" "${1#*\=}" "$@"
		while [ ${#1} -gt 2 ]; do
			case $1 in (*[!a-zA-Z0-9_-]*) break; esac
			case '--prefix' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --prefix"
			esac
			case '--remote' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --remote"
			esac
			case '--url' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --url"
			esac
			case '--branch' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --branch"
			esac
			case '--squash' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --squash"
			esac
			case '--new' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --new"
			esac
			case '--help' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --help"
			esac
			case '--version' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --version"
			esac
			break
		done
		case ${OPTARG# } in
			*\ *)
				eval "set -- $OPTARG $1 $OPTARG"
				OPTIND=$((($#+1)/2)) OPTARG=$1; shift
				while [ $# -gt "$OPTIND" ]; do OPTARG="$OPTARG, $1"; shift; done
				set "Ambiguous option: $1 (could be $OPTARG)" ambiguous "$@"
				parser_error "$@" >&2 || exit $?
				echo "$1" >&2
				exit 1 ;;
			?*)
				[ "$2" = "$3" ] || OPTARG="$OPTARG=$2"
				shift 3; eval 'set -- "${OPTARG# }"' ${1+'"$@"'}; OPTARG= ;;
			*) shift 2
		esac
		case $1 in
			--?*=*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%%\=*}" "${OPTARG#*\=}"' ${1+'"$@"'}
				;;
			--no-*|--without-*) unset OPTARG ;;
			-[prlb]?*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%"${OPTARG#??}"}" "${OPTARG#??}"' ${1+'"$@"'}
				;;
			-[snhv]?*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%"${OPTARG#??}"}" -"${OPTARG#??}"' ${1+'"$@"'}
				case $2 in --*) set -- "$1" unknown "$2" && GMASH_MONO_SUB_ARGR=x; esac;OPTARG= ;;
			+*) unset OPTARG ;;
		esac
		case $1 in
			'-p'|'--prefix')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_MONO_SUB_PREFIX="$OPTARG"
				shift ;;
			'-r'|'--remote')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_MONO_SUB_REMOTE="$OPTARG"
				shift ;;
			'-l'|'--url')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_MONO_SUB_URL="$OPTARG"
				shift ;;
			'-b'|'--branch')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_MONO_SUB_BR="$OPTARG"
				shift ;;
			'-s'|'--squash')
				[ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
				eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
				export GMASH_MONO_SUB_SQUASH="$OPTARG"
				;;
			'-n'|'--new')
				[ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
				eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
				export GMASH_MONO_SUB_NEW="$OPTARG"
				;;
			'-h'|'--help')
				gmash_mono_sub_help
				exit 0 ;;
			'-v'|'--version')
				echo "${GMASH_MONO_SUB_VERSION}"
				exit 0 ;;
			--)
				shift
				while [ $# -gt 0 ]; do
					GMASH_MONO_SUB_ARGR="${GMASH_MONO_SUB_ARGR} \"\${$(($OPTIND-$#))}\""
					shift
				done
				break ;;
			[-+]?*) set "unknown" "$1"; break ;;
			*)
				GMASH_MONO_SUB_ARGR="${GMASH_MONO_SUB_ARGR} \"\${$(($OPTIND-$#))}\""
		esac
		shift
	done
	[ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }
	case $1 in
		unknown) set "Unrecognized option: $2" "$@" ;;
		noarg) set "Does not allow an argument: $2" "$@" ;;
		required) set "Requires an argument: $2" "$@" ;;
		pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;
		notcmd) set "Not a command: $2" "$@" ;;
		*) set "Validation error ($1): $2" "$@"
	esac
	parser_error "$@" >&2 || exit $?
	echo "$1" >&2
	exit 1
}
gmash_mono_sub_help() {
cat<<'GETOPTIONSHERE'
Usage: gmash mono sub <-p <subtreePrefixPath>> <-r <remoteAlias>> <-l <remoteUrl>> [-b <subtreeBranch>]
 
Add or re-configure a sub project to the mono repo as a subtree.
 
Parameters:
  -p,     --prefix <subtreePrefixPath>  Relative path inside the parent repo where the subtree will be added. Cannot be the root path. The path must be empty or non-existent in the parent repo. gmash will deny adding a subtree to a path which already contains any files.
  -r,     --remote <remoteAlias>        Remote alias to add to the parent repo, which will be refered to when pulling and pushing changes to the added subtree.
  -l,     --url <remoteURL>             Remote repository URL of the subtree to add. If not provided, gmash will attempt to find an existing GitHub repo at 'api-user/remote.git'. If no such repo exists and '--new' is passed: a new empty repo will be created at 'api-user/remote.git'.
  -b,     --branch [monoBranch = "main"] 
                                        Target branch of the subtree remote to pull in. Defaults to 'main'.
  -s,     --squash                      Instead of merging the entire history from the subtree project, produce only a single commit that contains all the differences to merge. Then, merge that new commit into the parent repo. Note, if you add a subtree with --squash, future
 pulls and pushes to that subtree should also be squashed.
  -n,     --new                         Create a new github repo for the added subtree, if the target subtree remote does not exist.
  
Display:
  -h,     --help                        Display gmash, command or subcommand help. Use -h or --help.
  -v,     --version                     [v0-0-0] Display command group version.
GETOPTIONSHERE
}
# Generated by getoptions (END)
# Generated by getoptions (BEGIN)
# URL: https://github.com/ko1nksm/getoptions (v3.3.2)
export GMASH_MONO_REMOVE_REMOTE=''
export GMASH_MONO_REMOVE_PREFIX=''
export GMASH_MONO_REMOVE_KEEP_REMOTE=''
GMASH_MONO_REMOVE_ARGR=''
gmash_parser_mono_remove() {
	OPTIND=$(($#+1))
	while OPTARG= && [ "${GMASH_MONO_REMOVE_ARGR}" != x ] && [ $# -gt 0 ]; do
		set -- "${1%%\=*}" "${1#*\=}" "$@"
		while [ ${#1} -gt 2 ]; do
			case $1 in (*[!a-zA-Z0-9_-]*) break; esac
			case '--remote' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --remote"
			esac
			case '--prefix' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --prefix"
			esac
			case '--keep-remote' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --keep-remote"
			esac
			case '--help' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --help"
			esac
			case '--version' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --version"
			esac
			break
		done
		case ${OPTARG# } in
			*\ *)
				eval "set -- $OPTARG $1 $OPTARG"
				OPTIND=$((($#+1)/2)) OPTARG=$1; shift
				while [ $# -gt "$OPTIND" ]; do OPTARG="$OPTARG, $1"; shift; done
				set "Ambiguous option: $1 (could be $OPTARG)" ambiguous "$@"
				parser_error "$@" >&2 || exit $?
				echo "$1" >&2
				exit 1 ;;
			?*)
				[ "$2" = "$3" ] || OPTARG="$OPTARG=$2"
				shift 3; eval 'set -- "${OPTARG# }"' ${1+'"$@"'}; OPTARG= ;;
			*) shift 2
		esac
		case $1 in
			--?*=*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%%\=*}" "${OPTARG#*\=}"' ${1+'"$@"'}
				;;
			--no-*|--without-*) unset OPTARG ;;
			-[rp]?*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%"${OPTARG#??}"}" "${OPTARG#??}"' ${1+'"$@"'}
				;;
			-[khv]?*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%"${OPTARG#??}"}" -"${OPTARG#??}"' ${1+'"$@"'}
				case $2 in --*) set -- "$1" unknown "$2" && GMASH_MONO_REMOVE_ARGR=x; esac;OPTARG= ;;
			+*) unset OPTARG ;;
		esac
		case $1 in
			'-r'|'--remote')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_MONO_REMOVE_REMOTE="$OPTARG"
				shift ;;
			'-p'|'--prefix')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_MONO_REMOVE_PREFIX="$OPTARG"
				shift ;;
			'-k'|'--keep-remote')
				[ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
				eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
				export GMASH_MONO_REMOVE_KEEP_REMOTE="$OPTARG"
				;;
			'-h'|'--help')
				gmash_mono_remove_help
				exit 0 ;;
			'-v'|'--version')
				echo "${GMASH_MONO_REMOVE_VERSION}"
				exit 0 ;;
			--)
				shift
				while [ $# -gt 0 ]; do
					GMASH_MONO_REMOVE_ARGR="${GMASH_MONO_REMOVE_ARGR} \"\${$(($OPTIND-$#))}\""
					shift
				done
				break ;;
			[-+]?*) set "unknown" "$1"; break ;;
			*)
				GMASH_MONO_REMOVE_ARGR="${GMASH_MONO_REMOVE_ARGR} \"\${$(($OPTIND-$#))}\""
		esac
		shift
	done
	[ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }
	case $1 in
		unknown) set "Unrecognized option: $2" "$@" ;;
		noarg) set "Does not allow an argument: $2" "$@" ;;
		required) set "Requires an argument: $2" "$@" ;;
		pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;
		notcmd) set "Not a command: $2" "$@" ;;
		*) set "Validation error ($1): $2" "$@"
	esac
	parser_error "$@" >&2 || exit $?
	echo "$1" >&2
	exit 1
}
gmash_mono_remove_help() {
cat<<'GETOPTIONSHERE'
Usage: gmash mono remove -r [remote] -p [prefix] [-k]
  
Remove a subtree from the monorepo.
  
Parameters:
  -r,     --remote <subtreeRemote>      Target subtree remote alias.
  -p,     --prefix <subtreePrefixPath>  Subtree prefix path in the monorepo.
  -k,     --keep-remote                 Keep the remote alias in the parent repo even if it is no longer used.
  
Display:
  -h,     --help                        Display gmash, command or subcommand help. Use -h or --help.
  -v,     --version                     [v0-0-0] Display command group version.
GETOPTIONSHERE
}
# Generated by getoptions (END)
# Generated by getoptions (BEGIN)
# URL: https://github.com/ko1nksm/getoptions (v3.3.2)
export GMASH_MONO_PULL_REMOTE=''
export GMASH_MONO_PULL_BRANCH=''
export GMASH_MONO_PULL_PREFIX=''
export GMASH_MONO_PULL_ALL=''
GMASH_MONO_PULL_ARGR=''
gmash_parser_mono_pull() {
	OPTIND=$(($#+1))
	while OPTARG= && [ "${GMASH_MONO_PULL_ARGR}" != x ] && [ $# -gt 0 ]; do
		set -- "${1%%\=*}" "${1#*\=}" "$@"
		while [ ${#1} -gt 2 ]; do
			case $1 in (*[!a-zA-Z0-9_-]*) break; esac
			case '--remote' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --remote"
			esac
			case '--branch' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --branch"
			esac
			case '--prefix' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --prefix"
			esac
			case '--all' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --all"
			esac
			case '--help' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --help"
			esac
			case '--version' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --version"
			esac
			break
		done
		case ${OPTARG# } in
			*\ *)
				eval "set -- $OPTARG $1 $OPTARG"
				OPTIND=$((($#+1)/2)) OPTARG=$1; shift
				while [ $# -gt "$OPTIND" ]; do OPTARG="$OPTARG, $1"; shift; done
				set "Ambiguous option: $1 (could be $OPTARG)" ambiguous "$@"
				parser_error "$@" >&2 || exit $?
				echo "$1" >&2
				exit 1 ;;
			?*)
				[ "$2" = "$3" ] || OPTARG="$OPTARG=$2"
				shift 3; eval 'set -- "${OPTARG# }"' ${1+'"$@"'}; OPTARG= ;;
			*) shift 2
		esac
		case $1 in
			--?*=*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%%\=*}" "${OPTARG#*\=}"' ${1+'"$@"'}
				;;
			--no-*|--without-*) unset OPTARG ;;
			-[rbp]?*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%"${OPTARG#??}"}" "${OPTARG#??}"' ${1+'"$@"'}
				;;
			-[ahv]?*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%"${OPTARG#??}"}" -"${OPTARG#??}"' ${1+'"$@"'}
				case $2 in --*) set -- "$1" unknown "$2" && GMASH_MONO_PULL_ARGR=x; esac;OPTARG= ;;
			+*) unset OPTARG ;;
		esac
		case $1 in
			'-r'|'--remote')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_MONO_PULL_REMOTE="$OPTARG"
				shift ;;
			'-b'|'--branch')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_MONO_PULL_BRANCH="$OPTARG"
				shift ;;
			'-p'|'--prefix')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_MONO_PULL_PREFIX="$OPTARG"
				shift ;;
			'-a'|'--all')
				[ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
				eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
				export GMASH_MONO_PULL_ALL="$OPTARG"
				;;
			'-h'|'--help')
				gmash_mono_pull_help
				exit 0 ;;
			'-v'|'--version')
				echo "${GMASH_MONO_PULL_VERSION}"
				exit 0 ;;
			--)
				shift
				while [ $# -gt 0 ]; do
					GMASH_MONO_PULL_ARGR="${GMASH_MONO_PULL_ARGR} \"\${$(($OPTIND-$#))}\""
					shift
				done
				break ;;
			[-+]?*) set "unknown" "$1"; break ;;
			*)
				GMASH_MONO_PULL_ARGR="${GMASH_MONO_PULL_ARGR} \"\${$(($OPTIND-$#))}\""
		esac
		shift
	done
	[ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }
	case $1 in
		unknown) set "Unrecognized option: $2" "$@" ;;
		noarg) set "Does not allow an argument: $2" "$@" ;;
		required) set "Requires an argument: $2" "$@" ;;
		pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;
		notcmd) set "Not a command: $2" "$@" ;;
		*) set "Validation error ($1): $2" "$@"
	esac
	parser_error "$@" >&2 || exit $?
	echo "$1" >&2
	exit 1
}
gmash_mono_pull_help() {
cat<<'GETOPTIONSHERE'
Usage: gmash mono pull -r [repo] -b [branch]
  
Pull subtree changes to monorepo.
  
Parameters:
  -r,     --remote <subtreeRemote>      Target subtree remote alias.
  -b,     --branch <subtreeBranch>      Target subtree branch.
  -p,     --prefix <subtreePrefixPath>  Subtree prefix path in the monorepo.
  -a,     --all                         Patch all subtrees based on gmash metadata.
  
Display:
  -h,     --help                        Display gmash, command or subcommand help. Use -h or --help.
  -v,     --version                     [v0-0-0] Display command group version.
GETOPTIONSHERE
}
# Generated by getoptions (END)
# Generated by getoptions (BEGIN)
# URL: https://github.com/ko1nksm/getoptions (v3.3.2)
export GMASH_MONO_PATCH_BR=''
export GMASH_MONO_PATCH_PATH=''
export GMASH_MONO_PATCH_REMOTE=''
export GMASH_MONO_PATCH_TGTBR=''
export GMASH_MONO_PATCH_TGTUSER=''
export GMASH_MONO_PATCH_TEMPBR=''
export GMASH_MONO_PATCH_TEMPDIR=''
export GMASH_MONO_PATCH_USER=''
export GMASH_MONO_PATCH_URL=''
export GMASH_MONO_PATCH_ALL=''
export GMASH_MONO_PATCH_MAKEPR=''
export GMASH_MONO_PATCH_SQUASH=''
GMASH_MONO_PATCH_ARGR=''
gmash_parser_mono_push() {
	OPTIND=$(($#+1))
	while OPTARG= && [ "${GMASH_MONO_PATCH_ARGR}" != x ] && [ $# -gt 0 ]; do
		set -- "${1%%\=*}" "${1#*\=}" "$@"
		while [ ${#1} -gt 2 ]; do
			case $1 in (*[!a-zA-Z0-9_-]*) break; esac
			case '--br' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --br"
			esac
			case '--path' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --path"
			esac
			case '--remote' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --remote"
			esac
			case '--tgtbr' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --tgtbr"
			esac
			case '--tgtuser' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --tgtuser"
			esac
			case '--tempbr' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --tempbr"
			esac
			case '--tempdir' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --tempdir"
			esac
			case '--user' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --user"
			esac
			case '--url' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --url"
			esac
			case '--all' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --all"
			esac
			case '--make-pr' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --make-pr"
			esac
			case '--squash' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --squash"
			esac
			case '--help' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --help"
			esac
			case '--version' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --version"
			esac
			break
		done
		case ${OPTARG# } in
			*\ *)
				eval "set -- $OPTARG $1 $OPTARG"
				OPTIND=$((($#+1)/2)) OPTARG=$1; shift
				while [ $# -gt "$OPTIND" ]; do OPTARG="$OPTARG, $1"; shift; done
				set "Ambiguous option: $1 (could be $OPTARG)" ambiguous "$@"
				parser_error "$@" >&2 || exit $?
				echo "$1" >&2
				exit 1 ;;
			?*)
				[ "$2" = "$3" ] || OPTARG="$OPTARG=$2"
				shift 3; eval 'set -- "${OPTARG# }"' ${1+'"$@"'}; OPTARG= ;;
			*) shift 2
		esac
		case $1 in
			--?*=*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%%\=*}" "${OPTARG#*\=}"' ${1+'"$@"'}
				;;
			--no-*|--without-*) unset OPTARG ;;
			-[bprBUtTul]?*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%"${OPTARG#??}"}" "${OPTARG#??}"' ${1+'"$@"'}
				;;
			-[aPshv]?*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%"${OPTARG#??}"}" -"${OPTARG#??}"' ${1+'"$@"'}
				case $2 in --*) set -- "$1" unknown "$2" && GMASH_MONO_PATCH_ARGR=x; esac;OPTARG= ;;
			+*) unset OPTARG ;;
		esac
		case $1 in
			'-b'|'--br')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_MONO_PATCH_BR="$OPTARG"
				shift ;;
			'-p'|'--path')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_MONO_PATCH_PATH="$OPTARG"
				shift ;;
			'-r'|'--remote')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_MONO_PATCH_REMOTE="$OPTARG"
				shift ;;
			'-B'|'--tgtbr')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_MONO_PATCH_TGTBR="$OPTARG"
				shift ;;
			'-U'|'--tgtuser')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_MONO_PATCH_TGTUSER="$OPTARG"
				shift ;;
			'-t'|'--tempbr')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_MONO_PATCH_TEMPBR="$OPTARG"
				shift ;;
			'-T'|'--tempdir')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_MONO_PATCH_TEMPDIR="$OPTARG"
				shift ;;
			'-u'|'--user')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_MONO_PATCH_USER="$OPTARG"
				shift ;;
			'-l'|'--url')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_MONO_PATCH_URL="$OPTARG"
				shift ;;
			'-a'|'--all')
				[ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
				eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
				export GMASH_MONO_PATCH_ALL="$OPTARG"
				;;
			'-P'|'--make-pr')
				[ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
				eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
				export GMASH_MONO_PATCH_MAKEPR="$OPTARG"
				;;
			'-s'|'--squash')
				[ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
				eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
				export GMASH_MONO_PATCH_SQUASH="$OPTARG"
				;;
			'-h'|'--help')
				gmash_mono_patch_help
				exit 0 ;;
			'-v'|'--version')
				echo "${GMASH_MONO_PATCH_VERSION}"
				exit 0 ;;
			--)
				shift
				while [ $# -gt 0 ]; do
					GMASH_MONO_PATCH_ARGR="${GMASH_MONO_PATCH_ARGR} \"\${$(($OPTIND-$#))}\""
					shift
				done
				break ;;
			[-+]?*) set "unknown" "$1"; break ;;
			*)
				GMASH_MONO_PATCH_ARGR="${GMASH_MONO_PATCH_ARGR} \"\${$(($OPTIND-$#))}\""
		esac
		shift
	done
	[ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }
	case $1 in
		unknown) set "Unrecognized option: $2" "$@" ;;
		noarg) set "Does not allow an argument: $2" "$@" ;;
		required) set "Requires an argument: $2" "$@" ;;
		pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;
		notcmd) set "Not a command: $2" "$@" ;;
		*) set "Validation error ($1): $2" "$@"
	esac
	parser_error "$@" >&2 || exit $?
	echo "$1" >&2
	exit 1
}
gmash_mono_patch_help() {
cat<<'GETOPTIONSHERE'
Usage: gmash mono push -r [repo] -b [branch]
  
Push changes in the mono repo to a sub project's remote.
  
Parameters:
  -b,     --br <monoBranch>             Source mono branch to pull changes from.
  -p,     --path <prefixPath>           Subtree prefix path in the monorepo.
  -r,     --remote <subtreeRemote>      Target subtree remote alias.
  -B,     --tgtbr <subtreeBranch>       Target subtree remote alias.
  -U,     --tgtuser <subtreeOwner>      Owner of the target subtree repo.
  -t,     --tempbr <tempBranch>         Owner of the target subtree repo.
  -T,     --tempdir <tempPath>          Owner of the target subtree repo.
  -u,     --user <tempPath>             Owner the mono repo. Defaults to current GitHub user.
  -l,     --url <repo>                  Target repository.
  -a,     --all                         Patch all known subtrees in the mono repo.
  -P,     --make-pr                     Make a pull request on GitHub with the patched changes.
  -s,     --squash                      Squash strategy when merging subtree changes. Must be consistent with  the previous pul of the subtree.
  
Display:
  -h,     --help                        Display gmash, command or subcommand help. Use -h or --help.
  -v,     --version                     [v0-0-0] Display command group version.
GETOPTIONSHERE
}
# Generated by getoptions (END)
# Generated by getoptions (BEGIN)
# URL: https://github.com/ko1nksm/getoptions (v3.3.2)
export GMASH_MONO_CONFIG_REMOTE=''
export GMASH_MONO_CONFIG_BRANCH=''
export GMASH_MONO_CONFIG_PREFIX=''
export GMASH_MONO_CONFIG_ALL=''
GMASH_MONO_CONFIG_ARGR=''
gmash_parser_mono_config() {
	OPTIND=$(($#+1))
	while OPTARG= && [ "${GMASH_MONO_CONFIG_ARGR}" != x ] && [ $# -gt 0 ]; do
		set -- "${1%%\=*}" "${1#*\=}" "$@"
		while [ ${#1} -gt 2 ]; do
			case $1 in (*[!a-zA-Z0-9_-]*) break; esac
			case '--remote' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --remote"
			esac
			case '--branch' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --branch"
			esac
			case '--prefix' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --prefix"
			esac
			case '--all' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --all"
			esac
			case '--help' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --help"
			esac
			case '--version' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --version"
			esac
			break
		done
		case ${OPTARG# } in
			*\ *)
				eval "set -- $OPTARG $1 $OPTARG"
				OPTIND=$((($#+1)/2)) OPTARG=$1; shift
				while [ $# -gt "$OPTIND" ]; do OPTARG="$OPTARG, $1"; shift; done
				set "Ambiguous option: $1 (could be $OPTARG)" ambiguous "$@"
				parser_error "$@" >&2 || exit $?
				echo "$1" >&2
				exit 1 ;;
			?*)
				[ "$2" = "$3" ] || OPTARG="$OPTARG=$2"
				shift 3; eval 'set -- "${OPTARG# }"' ${1+'"$@"'}; OPTARG= ;;
			*) shift 2
		esac
		case $1 in
			--?*=*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%%\=*}" "${OPTARG#*\=}"' ${1+'"$@"'}
				;;
			--no-*|--without-*) unset OPTARG ;;
			-[rbp]?*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%"${OPTARG#??}"}" "${OPTARG#??}"' ${1+'"$@"'}
				;;
			-[ahv]?*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%"${OPTARG#??}"}" -"${OPTARG#??}"' ${1+'"$@"'}
				case $2 in --*) set -- "$1" unknown "$2" && GMASH_MONO_CONFIG_ARGR=x; esac;OPTARG= ;;
			+*) unset OPTARG ;;
		esac
		case $1 in
			'-r'|'--remote')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_MONO_CONFIG_REMOTE="$OPTARG"
				shift ;;
			'-b'|'--branch')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_MONO_CONFIG_BRANCH="$OPTARG"
				shift ;;
			'-p'|'--prefix')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_MONO_CONFIG_PREFIX="$OPTARG"
				shift ;;
			'-a'|'--all')
				[ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
				eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
				export GMASH_MONO_CONFIG_ALL="$OPTARG"
				;;
			'-h'|'--help')
				gmash_mono_config_help
				exit 0 ;;
			'-v'|'--version')
				echo "${GMASH_MONO_CONFIG_VERSION}"
				exit 0 ;;
			--)
				shift
				while [ $# -gt 0 ]; do
					GMASH_MONO_CONFIG_ARGR="${GMASH_MONO_CONFIG_ARGR} \"\${$(($OPTIND-$#))}\""
					shift
				done
				break ;;
			[-+]?*) set "unknown" "$1"; break ;;
			*)
				GMASH_MONO_CONFIG_ARGR="${GMASH_MONO_CONFIG_ARGR} \"\${$(($OPTIND-$#))}\""
		esac
		shift
	done
	[ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }
	case $1 in
		unknown) set "Unrecognized option: $2" "$@" ;;
		noarg) set "Does not allow an argument: $2" "$@" ;;
		required) set "Requires an argument: $2" "$@" ;;
		pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;
		notcmd) set "Not a command: $2" "$@" ;;
		*) set "Validation error ($1): $2" "$@"
	esac
	parser_error "$@" >&2 || exit $?
	echo "$1" >&2
	exit 1
}
gmash_mono_config_help() {
cat<<'GETOPTIONSHERE'
Usage: gmash mono config -r [repo] -b [branch]
  
Configure a mono repo's remotes based on stored subproject metadata.
  
Parameters:
  -r,     --remote <subtreeRemote>      Target subtree remote alias.
  -b,     --branch <subtreeBranch>      Target subtree branch.
  -p,     --prefix <subtreePrefixPath>  Subtree prefix path in the monorepo.
  -a,     --all                         Configure all subtrees based on gmash metadata.
  
Display:
  -h,     --help                        Display gmash, command or subcommand help. Use -h or --help.
  -v,     --version                     [v0-0-0] Display command group version.
GETOPTIONSHERE
}
# Generated by getoptions (END)
