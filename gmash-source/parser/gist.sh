# Generated by getoptions (BEGIN)
# URL: https://github.com/ko1nksm/getoptions (v3.3.2)
export GMASH_GIST_USER=''
GMASH_GIST_ARGR=''
gmash_parser_gist() {
	OPTIND=$(($#+1))
	while OPTARG= && [ "${GMASH_GIST_ARGR}" != x ] && [ $# -gt 0 ]; do
		set -- "${1%%\=*}" "${1#*\=}" "$@"
		while [ ${#1} -gt 2 ]; do
			case $1 in (*[!a-zA-Z0-9_-]*) break; esac
			case '--user' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --user"
			esac
			case '--help' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --help"
			esac
			case '--version' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --version"
			esac
			break
		done
		case ${OPTARG# } in
			*\ *)
				eval "set -- $OPTARG $1 $OPTARG"
				OPTIND=$((($#+1)/2)) OPTARG=$1; shift
				while [ $# -gt "$OPTIND" ]; do OPTARG="$OPTARG, $1"; shift; done
				set "Ambiguous option: $1 (could be $OPTARG)" ambiguous "$@"
				parser_error "$@" >&2 || exit $?
				echo "$1" >&2
				exit 1 ;;
			?*)
				[ "$2" = "$3" ] || OPTARG="$OPTARG=$2"
				shift 3; eval 'set -- "${OPTARG# }"' ${1+'"$@"'}; OPTARG= ;;
			*) shift 2
		esac
		case $1 in
			--?*=*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%%\=*}" "${OPTARG#*\=}"' ${1+'"$@"'}
				;;
			--no-*|--without-*) unset OPTARG ;;
			-[u]?*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%"${OPTARG#??}"}" "${OPTARG#??}"' ${1+'"$@"'}
				;;
			-[hv]?*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%"${OPTARG#??}"}" -"${OPTARG#??}"' ${1+'"$@"'}
				case $2 in --*) set -- "$1" unknown "$2" && GMASH_GIST_ARGR=x; esac;OPTARG= ;;
			+*) unset OPTARG ;;
		esac
		case $1 in
			'-u'|'--user')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_GIST_USER="$OPTARG"
				shift ;;
			'-h'|'--help')
				gmash_gist_help
				exit 0 ;;
			'-v'|'--version')
				echo "${GMASH_GIST_VERSION}"
				exit 0 ;;
			--)
				while [ $# -gt 0 ]; do
					GMASH_GIST_ARGR="${GMASH_GIST_ARGR} \"\${$(($OPTIND-$#))}\""
					shift
				done
				break ;;
			[-+]?*) set "unknown" "$1"; break ;;
			*)
				case $1 in 'prepare'|'create'|'clone'|'recover'|'upload') ;;
					*) set "notcmd" "$1"; break
				esac
				while [ $# -gt 0 ]; do
					GMASH_GIST_ARGR="${GMASH_GIST_ARGR} \"\${$(($OPTIND-$#))}\""
					shift
				done
				break ;;
		esac
		shift
	done
	[ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }
	case $1 in
		unknown) set "Unrecognized option: $2" "$@" ;;
		noarg) set "Does not allow an argument: $2" "$@" ;;
		required) set "Requires an argument: $2" "$@" ;;
		pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;
		notcmd) set "Not a command: $2" "$@" ;;
		*) set "Validation error ($1): $2" "$@"
	esac
	parser_error "$@" >&2 || exit $?
	echo "$1" >&2
	exit 1
}
gmash_gist_help() {
cat<<'GETOPTIONSHERE'
Usage: gmash gist <sub-command> [[args]...]
  
Manage GitHub Gists with git-like functionality.
      Use 'upload' to create gists from local files and clone them back as git   repos.
      Use 'recover' to create mono-subtree repo from a set of selected gists.
      Use 'gmash mono' and 'gmash subtree' command groups for management of the  gist mono-repo.
      Use 'prepare','create' and 'clone' for lower level control. See sub-command  help for details.
  
Globals:
  -u,     --user <githubUser>           Global gist source(  owner) github user.
  
Sub-Commands:
  prepare                               Sets up a new gist with a title.md page with the same name as the   target source file(s).
  create                                Push all files in a directory as gists to GitHub. Adds a title.md   and readme.md by default.
  clone                                 Clones a gist to the local filesystem.
  recover                               Recover a user's gist(s) from GitHub remotes as git repos.
  upload                                Upload files to existing gists.
  
Display:
  -h,     --help                        Display gmash, command or subcommand help. Use -h or --help.
  -v,     --version                     [v0-0-0] Display command group version.
GETOPTIONSHERE
}
# Generated by getoptions (END)
# Generated by getoptions (BEGIN)
# URL: https://github.com/ko1nksm/getoptions (v3.3.2)
export GMASH_GIST_CLONE_USER=''
export GMASH_GIST_CLONE_HASH=''
export GMASH_GIST_CLONE_PATH=''
export GMASH_GIST_CLONE_PREFIX=''
export GMASH_GIST_CLONE_NAME=''
GMASH_GIST_CLONE_ARGR=''
gmash_parser_gist_clone() {
	OPTIND=$(($#+1))
	while OPTARG= && [ "${GMASH_GIST_CLONE_ARGR}" != x ] && [ $# -gt 0 ]; do
		set -- "${1%%\=*}" "${1#*\=}" "$@"
		while [ ${#1} -gt 2 ]; do
			case $1 in (*[!a-zA-Z0-9_-]*) break; esac
			case '--user' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --user"
			esac
			case '--hash' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --hash"
			esac
			case '--path' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --path"
			esac
			case '--prefix' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --prefix"
			esac
			case '--name' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --name"
			esac
			case '--help' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --help"
			esac
			case '--version' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --version"
			esac
			break
		done
		case ${OPTARG# } in
			*\ *)
				eval "set -- $OPTARG $1 $OPTARG"
				OPTIND=$((($#+1)/2)) OPTARG=$1; shift
				while [ $# -gt "$OPTIND" ]; do OPTARG="$OPTARG, $1"; shift; done
				set "Ambiguous option: $1 (could be $OPTARG)" ambiguous "$@"
				parser_error "$@" >&2 || exit $?
				echo "$1" >&2
				exit 1 ;;
			?*)
				[ "$2" = "$3" ] || OPTARG="$OPTARG=$2"
				shift 3; eval 'set -- "${OPTARG# }"' ${1+'"$@"'}; OPTARG= ;;
			*) shift 2
		esac
		case $1 in
			--?*=*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%%\=*}" "${OPTARG#*\=}"' ${1+'"$@"'}
				;;
			--no-*|--without-*) unset OPTARG ;;
			-[uspPn]?*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%"${OPTARG#??}"}" "${OPTARG#??}"' ${1+'"$@"'}
				;;
			-[hv]?*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%"${OPTARG#??}"}" -"${OPTARG#??}"' ${1+'"$@"'}
				case $2 in --*) set -- "$1" unknown "$2" && GMASH_GIST_CLONE_ARGR=x; esac;OPTARG= ;;
			+*) unset OPTARG ;;
		esac
		case $1 in
			'-u'|'--user')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_GIST_CLONE_USER="$OPTARG"
				shift ;;
			'-s'|'--hash')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_GIST_CLONE_HASH="$OPTARG"
				shift ;;
			'-p'|'--path')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_GIST_CLONE_PATH="$OPTARG"
				shift ;;
			'-P'|'--prefix')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_GIST_CLONE_PREFIX="$OPTARG"
				shift ;;
			'-n'|'--name')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_GIST_CLONE_NAME="$OPTARG"
				shift ;;
			'-h'|'--help')
				gmash_gist_clone_help
				exit 0 ;;
			'-v'|'--version')
				echo "${GMASH_GIST_CLONE_VERSION}"
				exit 0 ;;
			--)
				shift
				while [ $# -gt 0 ]; do
					GMASH_GIST_CLONE_ARGR="${GMASH_GIST_CLONE_ARGR} \"\${$(($OPTIND-$#))}\""
					shift
				done
				break ;;
			[-+]?*) set "unknown" "$1"; break ;;
			*)
				GMASH_GIST_CLONE_ARGR="${GMASH_GIST_CLONE_ARGR} \"\${$(($OPTIND-$#))}\""
		esac
		shift
	done
	[ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }
	case $1 in
		unknown) set "Unrecognized option: $2" "$@" ;;
		noarg) set "Does not allow an argument: $2" "$@" ;;
		required) set "Requires an argument: $2" "$@" ;;
		pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;
		notcmd) set "Not a command: $2" "$@" ;;
		*) set "Validation error ($1): $2" "$@"
	esac
	parser_error "$@" >&2 || exit $?
	echo "$1" >&2
	exit 1
}
gmash_gist_clone_help() {
cat<<'GETOPTIONSHERE'
Usage: gmash gist clone [[args]...]
  
Clones a gist to the local filesystem as a git repository.
  
Params:
  -u,     --user <githubUser>           Target Gist GitHub username (owner).
  -s,     --hash <gistHash>             Hash of the gist to clone. Otherwise clones all gists for the   user.
  -p,     --path <clonePath>            Path to clone the gist to. Defaults to current if not passed.
  -P,     --prefix <prefix>             Add a prefix to the cloned gist directory name.
  -n,     --name <folderName>           Name for the cloned gist directory. Defaults to '[prefix]-[hash]'.
  
Display:
  -h,     --help                        Display gmash, command or subcommand help. Use -h or --help.
  -v,     --version                     [v0-0-0] Display subcommand version.
GETOPTIONSHERE
}
# Generated by getoptions (END)
# Generated by getoptions (BEGIN)
# URL: https://github.com/ko1nksm/getoptions (v3.3.2)
GMASH_GIST_CREATE_FILE=()
export GMASH_GIST_CREATE_TITLE=''
export GMASH_GIST_CREATE_NAME=''
export GMASH_GIST_CREATE_README=''
export GMASH_GIST_CREATE_DESC=''
export GMASH_GIST_CREATE_NOREADME='0'
export GMASH_GIST_CREATE_NOTITLE='0'
export GMASH_GIST_CREATE_PUBLIC='0'
GMASH_GIST_CREATE_ARGR=''
gmash_parser_gist_create() {
	OPTIND=$(($#+1))
	while OPTARG= && [ "${GMASH_GIST_CREATE_ARGR}" != x ] && [ $# -gt 0 ]; do
		set -- "${1%%\=*}" "${1#*\=}" "$@"
		while [ ${#1} -gt 2 ]; do
			case $1 in (*[!a-zA-Z0-9_-]*) break; esac
			case '--file' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --file"
			esac
			case '--title' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --title"
			esac
			case '--name' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --name"
			esac
			case '--readme' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --readme"
			esac
			case '--desc' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --desc"
			esac
			case '--no-readme' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --no-readme"
			esac
			case '--no-title' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --no-title"
			esac
			case '--public' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --public"
			esac
			case '--help' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --help"
			esac
			case '--version' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --version"
			esac
			break
		done
		case ${OPTARG# } in
			*\ *)
				eval "set -- $OPTARG $1 $OPTARG"
				OPTIND=$((($#+1)/2)) OPTARG=$1; shift
				while [ $# -gt "$OPTIND" ]; do OPTARG="$OPTARG, $1"; shift; done
				set "Ambiguous option: $1 (could be $OPTARG)" ambiguous "$@"
				parser_error "$@" >&2 || exit $?
				echo "$1" >&2
				exit 1 ;;
			?*)
				[ "$2" = "$3" ] || OPTARG="$OPTARG=$2"
				shift 3; eval 'set -- "${OPTARG# }"' ${1+'"$@"'}; OPTARG= ;;
			*) shift 2
		esac
		case $1 in
			--?*=*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%%\=*}" "${OPTARG#*\=}"' ${1+'"$@"'}
				;;
			--no-*|--without-*) unset OPTARG ;;
			-[ftnrd]?*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%"${OPTARG#??}"}" "${OPTARG#??}"' ${1+'"$@"'}
				;;
			-[phv]?*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%"${OPTARG#??}"}" -"${OPTARG#??}"' ${1+'"$@"'}
				case $2 in --*) set -- "$1" unknown "$2" && GMASH_GIST_CREATE_ARGR=x; esac;OPTARG= ;;
			+*) unset OPTARG ;;
		esac
		case $1 in
			'-f'|'--file')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				append_array GMASH_GIST_CREATE_FILE
				shift ;;
			'-t'|'--title')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_GIST_CREATE_TITLE="$OPTARG"
				shift ;;
			'-n'|'--name')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_GIST_CREATE_NAME="$OPTARG"
				shift ;;
			'-r'|'--readme')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_GIST_CREATE_README="$OPTARG"
				shift ;;
			'-d'|'--desc')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_GIST_CREATE_DESC="$OPTARG"
				shift ;;
			'--no-readme')
				[ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
				eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG='1'
				export GMASH_GIST_CREATE_NOREADME="$OPTARG"
				;;
			'--no-title')
				[ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
				eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG='1'
				export GMASH_GIST_CREATE_NOTITLE="$OPTARG"
				;;
			'-p'|'--public')
				[ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
				eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG='1'
				export GMASH_GIST_CREATE_PUBLIC="$OPTARG"
				;;
			'-h'|'--help')
				gmash_gist_create_help
				exit 0 ;;
			'-v'|'--version')
				echo "${GMASH_GIST_CREATE_VERSION}"
				exit 0 ;;
			--)
				shift
				while [ $# -gt 0 ]; do
					GMASH_GIST_CREATE_ARGR="${GMASH_GIST_CREATE_ARGR} \"\${$(($OPTIND-$#))}\""
					shift
				done
				break ;;
			[-+]?*) set "unknown" "$1"; break ;;
			*)
				GMASH_GIST_CREATE_ARGR="${GMASH_GIST_CREATE_ARGR} \"\${$(($OPTIND-$#))}\""
		esac
		shift
	done
	[ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }
	case $1 in
		unknown) set "Unrecognized option: $2" "$@" ;;
		noarg) set "Does not allow an argument: $2" "$@" ;;
		required) set "Requires an argument: $2" "$@" ;;
		pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;
		notcmd) set "Not a command: $2" "$@" ;;
		*) set "Validation error ($1): $2" "$@"
	esac
	parser_error "$@" >&2 || exit $?
	echo "$1" >&2
	exit 1
}
gmash_gist_create_help() {
cat<<'GETOPTIONSHERE'
Usage: gmash gist create [<-f <file>>...] [-t [titleFile] | -n [name]]   [-r [readmeFile]] [-d [description]] [--no-readme] [--no-title]   [-p(--public)]
  
Sets up an empty gist with a 'title.md' and 'readme.md' file.
  
Params:
  -f,     --file <filePath>             File(s) to upload to the gist.
  -t,     --title <titleFile>           File to upload as the 'title.md'. Generates a default if not set.
  -n,     --name <gistName>             Title for the gist. Will set the name of the title file to   '[title].md'. Otherwise, --title file name.
  -r,     --readme <readmeFile>         File to upload as the 'README.md'. Generates a default if not set.
  -d,     --desc <gistDescription>      Description for the new gist.
  
Flags:
          --no-readme                   Don't generate or add a 'readme.md' file.
          --no-title                    Don't add a 'title.md' file. Implicitly disables 'readme.md' file. Creates an empty gist.
  -p,     --public                      Create a public gist. Default is secret.
  
Display:
  -h,     --help                        Display gmash, command or subcommand help. Use -h or --help.
  -v,     --version                     [v0-0-0] Display subcommand version.
GETOPTIONSHERE
}
# Generated by getoptions (END)
# Generated by getoptions (BEGIN)
# URL: https://github.com/ko1nksm/getoptions (v3.3.2)
export GMASH_GIST_PREPARE_TITLE=''
export GMASH_GIST_PREPARE_NAME=''
export GMASH_GIST_PREPARE_README=''
export GMASH_GIST_PREPARE_DESC=''
export GMASH_GIST_PREPARE_NOREADME='0'
export GMASH_GIST_PREPARE_NOTITLE='0'
export GMASH_GIST_PREPARE_PUBLIC='0'
GMASH_GIST_PREPARE_ARGR=''
gmash_parser_gist_prepare() {
	OPTIND=$(($#+1))
	while OPTARG= && [ "${GMASH_GIST_PREPARE_ARGR}" != x ] && [ $# -gt 0 ]; do
		set -- "${1%%\=*}" "${1#*\=}" "$@"
		while [ ${#1} -gt 2 ]; do
			case $1 in (*[!a-zA-Z0-9_-]*) break; esac
			case '--title' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --title"
			esac
			case '--name' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --name"
			esac
			case '--readme' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --readme"
			esac
			case '--desc' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --desc"
			esac
			case '--no-readme' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --no-readme"
			esac
			case '--no-title' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --no-title"
			esac
			case '--public' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --public"
			esac
			case '--help' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --help"
			esac
			case '--version' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --version"
			esac
			break
		done
		case ${OPTARG# } in
			*\ *)
				eval "set -- $OPTARG $1 $OPTARG"
				OPTIND=$((($#+1)/2)) OPTARG=$1; shift
				while [ $# -gt "$OPTIND" ]; do OPTARG="$OPTARG, $1"; shift; done
				set "Ambiguous option: $1 (could be $OPTARG)" ambiguous "$@"
				parser_error "$@" >&2 || exit $?
				echo "$1" >&2
				exit 1 ;;
			?*)
				[ "$2" = "$3" ] || OPTARG="$OPTARG=$2"
				shift 3; eval 'set -- "${OPTARG# }"' ${1+'"$@"'}; OPTARG= ;;
			*) shift 2
		esac
		case $1 in
			--?*=*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%%\=*}" "${OPTARG#*\=}"' ${1+'"$@"'}
				;;
			--no-*|--without-*) unset OPTARG ;;
			-[tnrd]?*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%"${OPTARG#??}"}" "${OPTARG#??}"' ${1+'"$@"'}
				;;
			-[NTPhv]?*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%"${OPTARG#??}"}" -"${OPTARG#??}"' ${1+'"$@"'}
				case $2 in --*) set -- "$1" unknown "$2" && GMASH_GIST_PREPARE_ARGR=x; esac;OPTARG= ;;
			+*) unset OPTARG ;;
		esac
		case $1 in
			'-t'|'--title')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_GIST_PREPARE_TITLE="$OPTARG"
				shift ;;
			'-n'|'--name')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_GIST_PREPARE_NAME="$OPTARG"
				shift ;;
			'-r'|'--readme')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_GIST_PREPARE_README="$OPTARG"
				shift ;;
			'-d'|'--desc')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_GIST_PREPARE_DESC="$OPTARG"
				shift ;;
			'-N'|'--no-readme')
				[ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
				eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG='1'
				export GMASH_GIST_PREPARE_NOREADME="$OPTARG"
				;;
			'-T'|'--no-title')
				[ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
				eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG='1'
				export GMASH_GIST_PREPARE_NOTITLE="$OPTARG"
				;;
			'-P'|'--public')
				[ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
				eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG='1'
				export GMASH_GIST_PREPARE_PUBLIC="$OPTARG"
				;;
			'-h'|'--help')
				gmash_gist_prepare_help
				exit 0 ;;
			'-v'|'--version')
				echo "${GMASH_GIST_PREPARE_VERSION}"
				exit 0 ;;
			--)
				shift
				while [ $# -gt 0 ]; do
					GMASH_GIST_PREPARE_ARGR="${GMASH_GIST_PREPARE_ARGR} \"\${$(($OPTIND-$#))}\""
					shift
				done
				break ;;
			[-+]?*) set "unknown" "$1"; break ;;
			*)
				GMASH_GIST_PREPARE_ARGR="${GMASH_GIST_PREPARE_ARGR} \"\${$(($OPTIND-$#))}\""
		esac
		shift
	done
	[ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }
	case $1 in
		unknown) set "Unrecognized option: $2" "$@" ;;
		noarg) set "Does not allow an argument: $2" "$@" ;;
		required) set "Requires an argument: $2" "$@" ;;
		pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;
		notcmd) set "Not a command: $2" "$@" ;;
		*) set "Validation error ($1): $2" "$@"
	esac
	parser_error "$@" >&2 || exit $?
	echo "$1" >&2
	exit 1
}
gmash_gist_prepare_help() {
cat<<'GETOPTIONSHERE'
Usage: gmash gist prepare [-t [titleFile] | -n [name]] [-r [readmeFile]] [-d [description]] [--no-readme] [--no-title] [-p(--public)]
  
  
Sets up an empty gist with a 'title.md' and 'readme.md' file.
  
Params:
  -t,     --title <titleFile>           File to upload as the 'title.md'. Generates a default if not set.
  -n,     --name <gistName>             Title for the gist. Will set the name of the title file to '[title].md'. Otherwise, --title file name.
  -r,     --readme <readmeFile>         File to upload as the 'README.md'. Generates a default if not set.
  -d,     --desc <gistDescription>      Description for the new gist.
  
Flags:
  -N,     --no-readme                   Dont generate or add a 'readme.md' file.
  -T,     --no-title                    Dont add a 'title.md' file. Implicitly disables 'readme.md' file. Creates an empty gist.
  -P,     --public                      Create a public gist. Default is secret.
  
Display:
  -h,     --help                        Display gmash, command or subcommand help. Use -h or --help.
  -v,     --version                     [v0-0-0] Display subcommand version.
GETOPTIONSHERE
}
# Generated by getoptions (END)
# Generated by getoptions (BEGIN)
# URL: https://github.com/ko1nksm/getoptions (v3.3.2)
export GMASH_GIST_RECOVER_USER=''
export GMASH_GIST_RECOVER_HASH=''
export GMASH_GIST_RECOVER_PATH=''
export GMASH_GIST_RECOVER_SECRET=''
export GMASH_GIST_RECOVER_PUBLIC=''
GMASH_GIST_RECOVER_ARGR=''
gmash_parser_gist_recover() {
	OPTIND=$(($#+1))
	while OPTARG= && [ "${GMASH_GIST_RECOVER_ARGR}" != x ] && [ $# -gt 0 ]; do
		set -- "${1%%\=*}" "${1#*\=}" "$@"
		while [ ${#1} -gt 2 ]; do
			case $1 in (*[!a-zA-Z0-9_-]*) break; esac
			case '--user' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --user"
			esac
			case '--hash' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --hash"
			esac
			case '--path' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --path"
			esac
			case '--secret' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --secret"
			esac
			case '--public' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --public"
			esac
			case '--help' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --help"
			esac
			case '--version' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --version"
			esac
			break
		done
		case ${OPTARG# } in
			*\ *)
				eval "set -- $OPTARG $1 $OPTARG"
				OPTIND=$((($#+1)/2)) OPTARG=$1; shift
				while [ $# -gt "$OPTIND" ]; do OPTARG="$OPTARG, $1"; shift; done
				set "Ambiguous option: $1 (could be $OPTARG)" ambiguous "$@"
				parser_error "$@" >&2 || exit $?
				echo "$1" >&2
				exit 1 ;;
			?*)
				[ "$2" = "$3" ] || OPTARG="$OPTARG=$2"
				shift 3; eval 'set -- "${OPTARG# }"' ${1+'"$@"'}; OPTARG= ;;
			*) shift 2
		esac
		case $1 in
			--?*=*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%%\=*}" "${OPTARG#*\=}"' ${1+'"$@"'}
				;;
			--no-*|--without-*) unset OPTARG ;;
			-[usp]?*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%"${OPTARG#??}"}" "${OPTARG#??}"' ${1+'"$@"'}
				;;
			-[sPhv]?*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%"${OPTARG#??}"}" -"${OPTARG#??}"' ${1+'"$@"'}
				case $2 in --*) set -- "$1" unknown "$2" && GMASH_GIST_RECOVER_ARGR=x; esac;OPTARG= ;;
			+*) unset OPTARG ;;
		esac
		case $1 in
			'-u'|'--user')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_GIST_RECOVER_USER="$OPTARG"
				shift ;;
			'-s'|'--hash')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_GIST_RECOVER_HASH="$OPTARG"
				shift ;;
			'-p'|'--path')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_GIST_RECOVER_PATH="$OPTARG"
				shift ;;
			'-s'|'--secret')
				[ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
				eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
				export GMASH_GIST_RECOVER_SECRET="$OPTARG"
				;;
			'-P'|'--public')
				[ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
				eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
				export GMASH_GIST_RECOVER_PUBLIC="$OPTARG"
				;;
			'-h'|'--help')
				gmash_gist_recover_help
				exit 0 ;;
			'-v'|'--version')
				echo "${GMASH_GIST_RECOVER_VERSION}"
				exit 0 ;;
			--)
				shift
				while [ $# -gt 0 ]; do
					GMASH_GIST_RECOVER_ARGR="${GMASH_GIST_RECOVER_ARGR} \"\${$(($OPTIND-$#))}\""
					shift
				done
				break ;;
			[-+]?*) set "unknown" "$1"; break ;;
			*)
				GMASH_GIST_RECOVER_ARGR="${GMASH_GIST_RECOVER_ARGR} \"\${$(($OPTIND-$#))}\""
		esac
		shift
	done
	[ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }
	case $1 in
		unknown) set "Unrecognized option: $2" "$@" ;;
		noarg) set "Does not allow an argument: $2" "$@" ;;
		required) set "Requires an argument: $2" "$@" ;;
		pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;
		notcmd) set "Not a command: $2" "$@" ;;
		*) set "Validation error ($1): $2" "$@"
	esac
	parser_error "$@" >&2 || exit $?
	echo "$1" >&2
	exit 1
}
gmash_gist_recover_help() {
cat<<'GETOPTIONSHERE'
Usage: gmash gist recover [[args]...]
  
Recover a user's gist(s) from GitHub remotes as git repos.
  
Params:
  -u,     --user <githubUser>           Target Gist GitHub username (owner).
  -s,     --hash <gistHash>             Hash of the gist to recover. Otherwise recovers all gists for the     user.
  -p,     --path <recoverPath>          Path to recover the gist to. Defaults to current if not passed.
  
Flags:
  -s,     --secret                      Recover secret gists, only applies when --hash is not specified.
  -P,     --public                      Recover public gists, only applies when --hash is not specified.
  
Display:
  -h,     --help                        Display gmash, command or subcommand help. Use -h or --help.
  -v,     --version                     [v0-0-0] Display subcommand version.
GETOPTIONSHERE
}
# Generated by getoptions (END)
# Generated by getoptions (BEGIN)
# URL: https://github.com/ko1nksm/getoptions (v3.3.2)
GMASH_GIST_UPLOAD_FILE=()
export GMASH_GIST_UPLOAD_TITLE=''
export GMASH_GIST_UPLOAD_NAME=''
export GMASH_GIST_UPLOAD_README=''
export GMASH_GIST_UPLOAD_DESC=''
export GMASH_GIST_UPLOAD_PATH=''
export GMASH_GIST_UPLOAD_USER=''
export GMASH_GIST_UPLOAD_NOREADME='0'
export GMASH_GIST_UPLOAD_NOTITLE='0'
export GMASH_GIST_UPLOAD_PUBLIC='0'
export GMASH_GIST_UPLOAD_ALL='0'
export GMASH_GIST_UPLOAD_ASONE='0'
export GMASH_GIST_UPLOAD_LIMIT=''
export GMASH_GIST_UPLOAD_NOEXTENSION='0'
GMASH_GIST_UPLOAD_ARGR=''
gmash_parser_gist_upload() {
	OPTIND=$(($#+1))
	while OPTARG= && [ "${GMASH_GIST_UPLOAD_ARGR}" != x ] && [ $# -gt 0 ]; do
		set -- "${1%%\=*}" "${1#*\=}" "$@"
		while [ ${#1} -gt 2 ]; do
			case $1 in (*[!a-zA-Z0-9_-]*) break; esac
			case '--file' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --file"
			esac
			case '--title' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --title"
			esac
			case '--name' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --name"
			esac
			case '--readme' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --readme"
			esac
			case '--desc' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --desc"
			esac
			case '--path' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --path"
			esac
			case '--user' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --user"
			esac
			case '--no-readme' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --no-readme"
			esac
			case '--no-title' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --no-title"
			esac
			case '--public' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --public"
			esac
			case '--all' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --all"
			esac
			case '--asone' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --asone"
			esac
			case '--limit' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --limit"
			esac
			case '--no-extension' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --no-extension"
			esac
			case '--help' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --help"
			esac
			case '--version' in
				"$1") OPTARG=; break ;;
				$1*) OPTARG="$OPTARG --version"
			esac
			break
		done
		case ${OPTARG# } in
			*\ *)
				eval "set -- $OPTARG $1 $OPTARG"
				OPTIND=$((($#+1)/2)) OPTARG=$1; shift
				while [ $# -gt "$OPTIND" ]; do OPTARG="$OPTARG, $1"; shift; done
				set "Ambiguous option: $1 (could be $OPTARG)" ambiguous "$@"
				parser_error "$@" >&2 || exit $?
				echo "$1" >&2
				exit 1 ;;
			?*)
				[ "$2" = "$3" ] || OPTARG="$OPTARG=$2"
				shift 3; eval 'set -- "${OPTARG# }"' ${1+'"$@"'}; OPTARG= ;;
			*) shift 2
		esac
		case $1 in
			--?*=*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%%\=*}" "${OPTARG#*\=}"' ${1+'"$@"'}
				;;
			--no-*|--without-*) unset OPTARG ;;
			-[ftnrdpul]?*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%"${OPTARG#??}"}" "${OPTARG#??}"' ${1+'"$@"'}
				;;
			-[NTPAaehv]?*) OPTARG=$1; shift
				eval 'set -- "${OPTARG%"${OPTARG#??}"}" -"${OPTARG#??}"' ${1+'"$@"'}
				case $2 in --*) set -- "$1" unknown "$2" && GMASH_GIST_UPLOAD_ARGR=x; esac;OPTARG= ;;
			+*) unset OPTARG ;;
		esac
		case $1 in
			'-f'|'--file')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				append_array GMASH_GIST_UPLOAD_FILE
				shift ;;
			'-t'|'--title')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_GIST_UPLOAD_TITLE="$OPTARG"
				shift ;;
			'-n'|'--name')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_GIST_UPLOAD_NAME="$OPTARG"
				shift ;;
			'-r'|'--readme')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_GIST_UPLOAD_README="$OPTARG"
				shift ;;
			'-d'|'--desc')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_GIST_UPLOAD_DESC="$OPTARG"
				shift ;;
			'-p'|'--path')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_GIST_UPLOAD_PATH="$OPTARG"
				shift ;;
			'-u'|'--user')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_GIST_UPLOAD_USER="$OPTARG"
				shift ;;
			'-N'|'--no-readme')
				[ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
				eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG='1'
				export GMASH_GIST_UPLOAD_NOREADME="$OPTARG"
				;;
			'-T'|'--no-title')
				[ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
				eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG='1'
				export GMASH_GIST_UPLOAD_NOTITLE="$OPTARG"
				;;
			'-P'|'--public')
				[ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
				eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG='1'
				export GMASH_GIST_UPLOAD_PUBLIC="$OPTARG"
				;;
			'-A'|'--all')
				[ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
				eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG='1'
				export GMASH_GIST_UPLOAD_ALL="$OPTARG"
				;;
			'-a'|'--asone')
				[ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
				eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG='1'
				export GMASH_GIST_UPLOAD_ASONE="$OPTARG"
				;;
			'-l'|'--limit')
				[ $# -le 1 ] && set "required" "$1" && break
				OPTARG=$2
				export GMASH_GIST_UPLOAD_LIMIT="$OPTARG"
				shift ;;
			'-e'|'--no-extension')
				[ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
				eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG='1'
				export GMASH_GIST_UPLOAD_NOEXTENSION="$OPTARG"
				;;
			'-h'|'--help')
				gmash_gist_upload_help
				exit 0 ;;
			'-v'|'--version')
				echo "${GMASH_GIST_UPLOAD_VERSION}"
				exit 0 ;;
			--)
				shift
				while [ $# -gt 0 ]; do
					GMASH_GIST_UPLOAD_ARGR="${GMASH_GIST_UPLOAD_ARGR} \"\${$(($OPTIND-$#))}\""
					shift
				done
				break ;;
			[-+]?*) set "unknown" "$1"; break ;;
			*)
				GMASH_GIST_UPLOAD_ARGR="${GMASH_GIST_UPLOAD_ARGR} \"\${$(($OPTIND-$#))}\""
		esac
		shift
	done
	[ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }
	case $1 in
		unknown) set "Unrecognized option: $2" "$@" ;;
		noarg) set "Does not allow an argument: $2" "$@" ;;
		required) set "Requires an argument: $2" "$@" ;;
		pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;
		notcmd) set "Not a command: $2" "$@" ;;
		*) set "Validation error ($1): $2" "$@"
	esac
	parser_error "$@" >&2 || exit $?
	echo "$1" >&2
	exit 1
}
gmash_gist_upload_help() {
cat<<'GETOPTIONSHERE'
Usage: gmash gist upload  <<-f <fileOrPath>> [-f <fileOrPath>]...> [-t <titleFile> | -n <name>] [-r <readmeFile>] [-d <description>] [-p <cloneToPath>] [-u <githubUser>] [--no-readme] [--no-title] [-P(--public)] [-A(--all)] [-a(--asone)][-e(--no-extension)] [-l <limit>]

  
Create gists from given file paths and clone them as a local git
repository. If '--all' is passed, push all files inside dir paths as
separate gists to GitHub. Use '--no-extension' to combine files with the
same base name into one gist. Pass '--as-one' to push each dir's files as
a single gist. Adds a 'title.md' and 'readme.md' by default.
  
Required:
  -f,     --file <filePath>             File(s) to upload to the gist.
Optional Params:
  -t,     --title <titleFile>           File to upload as the 'title.md'. Generates a default if not set.
  -n,     --name <gistName>             Title for the gist. Will set the name of the title file to   '[title].md'. Otherwise, --title file name.
  -r,     --readme <readmeFile>         File to upload as the 'README.md'. Generates a default if not set.
  -d,     --desc <gistDescription>      Description for the new gist.
  -p,     --path <cloneToPath>          Path to clone the gist repository to.
  -u,     --user <githubUser>           Target Gist GitHub username (owner).
Optional Flags:
  -N,     --no-readme                   Dont generate or add a 'readme.md' file.
  -T,     --no-title                    Dont add a 'title.md' file. Implicitly disables 'readme.md' file.   Creates an empty gist.
  -P,     --public                      Create a public gist. Default is secret.
'--all' Mode Flags:
  -A,     --all                         Interpret all '-f(--file)' paths as directories and push all files   inside them as separate gists.
  -a,     --asone                       Push each dir's files as a single gist.
  -l,     --limit <limit>               Maximum number of gists to create. Defaults to 100 (in-case of   unintentional overload).
  -e,     --no-extension                Ignore source file extensions when naming gists and grouping gist   sources.
  
Display:
  -h,     --help                        Display gmash, command or subcommand help. Use -h or --help.
  -v,     --version                     [v0-0-0] Display subcommand version.
 
Examples:
  Case 1 : Create a gist from one or more files.
  ``` bash
  gmash gist upload -f file1 -f file2 -n 'foo-gist' -d 'description of my gist'
  ```
  
  Case 2 : Create a separate gist for every file in a path, merge files with the same base name.
  ``` bash
  gmash gist upload -A --no-readme --no-extension
  # Given 'dir1' and 'dir2' contain files 'foo.cpp', 'bar.cpp','foo.hpp', 'bar.hpp' respectively,
  # 2 gists will be created and cloned to dirs: 'foo' and 'bar' relative to '--path'.
  ```
  Case 3 : Create a separate gist for every directory in a path, merging all files in each dir.
  ```
  gmash gist upload -A -a -f path1 -f path2
  # Given 'path1' and 'path2' contain dirs 'foo.', 'bar'. 2 gists will be
  # created and cloned to dirs: 'foo' and 'bar' relative to '--path'.
  ```
GETOPTIONSHERE
}
# Generated by getoptions (END)
